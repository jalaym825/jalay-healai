import { StreamSfuClient } from '../StreamSfuClient';
import { TrackInfo, TrackType } from '../gen/video/sfu/models/models';
import { CallState } from '../store';
import { PublishOptions } from '../types';
import { Dispatcher } from './Dispatcher';
export type PublisherConstructorOpts = {
    sfuClient: StreamSfuClient;
    state: CallState;
    dispatcher: Dispatcher;
    connectionConfig?: RTCConfiguration;
    isDtxEnabled: boolean;
    isRedEnabled: boolean;
    onUnrecoverableError?: () => void;
    logTag: string;
};
/**
 * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU
 *
 * @internal
 */
export declare class Publisher {
    private readonly logger;
    private pc;
    private readonly state;
    private readonly transceiverCache;
    private readonly trackLayersCache;
    private readonly publishOptsForTrack;
    /**
     * An array maintaining the order how transceivers were added to the peer connection.
     * This is needed because some browsers (Firefox) don't reliably report
     * trackId and `mid` parameters.
     *
     * @internal
     */
    private readonly transceiverInitOrder;
    private readonly isDtxEnabled;
    private readonly isRedEnabled;
    private readonly unsubscribeOnIceRestart;
    private readonly unsubscribeChangePublishQuality;
    private readonly onUnrecoverableError?;
    private isIceRestarting;
    private sfuClient;
    /**
     * Constructs a new `Publisher` instance.
     */
    constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, onUnrecoverableError, logTag, }: PublisherConstructorOpts);
    private createPeerConnection;
    /**
     * Closes the publisher PeerConnection and cleans up the resources.
     */
    close: ({ stopTracks }: {
        stopTracks: boolean;
    }) => void;
    /**
     * Detaches the event handlers from the `RTCPeerConnection`.
     * This is useful when we want to replace the `RTCPeerConnection`
     * instance with a new one (in case of migration).
     */
    detachEventHandlers: () => void;
    /**
     * Starts publishing the given track of the given media stream.
     *
     * Consecutive calls to this method will replace the stream.
     * The previous stream will be stopped.
     *
     * @param mediaStream the media stream to publish.
     * @param track the track to publish.
     * @param trackType the track type to publish.
     * @param opts the optional publish options to use.
     */
    publishStream: (mediaStream: MediaStream, track: MediaStreamTrack, trackType: TrackType, opts?: PublishOptions) => Promise<void>;
    /**
     * Adds a new transceiver to the peer connection.
     * This needs to be called when a new track kind is added to the peer connection.
     * In other cases, use `updateTransceiver` method.
     */
    private addTransceiver;
    /**
     * Updates the given transceiver with the new track.
     * Stops the previous track and replaces it with the new one.
     */
    private updateTransceiver;
    /**
     * Stops publishing the given track type to the SFU, if it is currently being published.
     * Underlying track will be stopped and removed from the publisher.
     * @param trackType the track type to unpublish.
     * @param stopTrack specifies whether track should be stopped or just disabled
     */
    unpublishStream: (trackType: TrackType, stopTrack: boolean) => Promise<void>;
    /**
     * Returns true if the given track type is currently being published to the SFU.
     *
     * @param trackType the track type to check.
     */
    isPublishing: (trackType: TrackType) => boolean;
    private notifyTrackMuteStateChanged;
    /**
     * Stops publishing all tracks and stop all tracks.
     */
    private stopPublishing;
    private changePublishQuality;
    /**
     * Returns the result of the `RTCPeerConnection.getStats()` method
     * @param selector
     * @returns
     */
    getStats: (selector?: MediaStreamTrack | null | undefined) => Promise<RTCStatsReport>;
    private getCodecPreferences;
    private onIceCandidate;
    /**
     * Sets the SFU client to use.
     *
     * @param sfuClient the SFU client to use.
     */
    setSfuClient: (sfuClient: StreamSfuClient) => void;
    /**
     * Restarts the ICE connection and renegotiates with the SFU.
     */
    restartIce: () => Promise<void>;
    private onNegotiationNeeded;
    /**
     * Initiates a new offer/answer exchange with the currently connected SFU.
     *
     * @param options the optional offer options to use.
     */
    private negotiate;
    private enableHighQualityAudio;
    /**
     * Returns a list of tracks that are currently being published.
     *
     * @internal
     * @param sdp an optional SDP to extract the `mid` from.
     */
    getAnnouncedTracks: (sdp?: string) => TrackInfo[];
    private computeLayers;
    private onIceCandidateError;
    private onIceConnectionStateChange;
    private onIceGatheringStateChange;
    private onSignalingStateChange;
}
